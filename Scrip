--[[
  üöÄ SCRIPT CONSTRUCTOR REFACTORIZADO
  
  Adaptado para usar:
  1. La estructura de secciones (AddSection)
  2. El componente Toggle Button (AddToggle) para control de estado.
--]]

-- Carga de la UI/HUD (Aseg√∫rate de que este enlace sea el RAW de tu RainbowUI MEJORADA)
local LIBRARY_RAW_LINK = "https://https://raw.githubusercontent.com/inmortales-likes-bot/Lua/refs/heads/main/Hud" 
-- NOTA: He asumido que el archivo se llama 'RainbowUI.lua'
local LibraryCode = game:HttpGet(LIBRARY_RAW_LINK, true)
local RainbowUI = loadstring(LibraryCode)()

local hud = RainbowUI:CreateWindow(250, 400) -- Ancho ajustado a 250, Alto inicial a 400
hud:Notify("Script Constructor Cargado!", 1.5)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- =========================
-- Variables y utilidades (Mantenidas del script original)
-- =========================

-- Variables de control
local teleporting = false -- Bucle BUSCAR
local multiTeleporting = false -- Bucle PICKUPS
local stickerTeleporting = false -- Bucle STICKERS

local teleportObjectName = nil
local notifiedNoObjects = false
local TELEPORT_INTERVAL = 0.1

local MULTI_TELEPORT_INTERVAL = 0.4
local multiPickupSlotNames = { "RevealPickupsSteveEagle", "RevealPickupsSteveGecko", "RevealPickupsSteveMantisShrimp", "RevealPickupsSteveSnowLeopard", }
local multiNotifiedNoObjects = false
local multiNotifiedError = false

local STICKER_TELEPORT_INTERVAL = 0.4
local stickerPaths = {
    "Stickers.Cheetah.CheckpointNoSticker00A", "ActiveStickers.d6001", "Stickers.Cheetah.CheckpointNoSticker01A", 
    "Stickers.Cheetah.CheckpointNoSticker01B", "ActiveStickers.d6002", "Stickers.Cheetah.CheckpointNoSticker02A", 
    "ActiveStickers.d6003", "ActiveStickers.d6004", "ActiveStickers.d6005", "ActiveStickers.d6006", 
    "Stickers.SnowLeopard.CheckpointNoSticker06A", "Stickers.SnowLeopard.CheckpointNoSticker06B", "ActiveStickers.d6007", 
    "Stickers.SnowLeopard.CheckpointNoSticker07A", "ActiveStickers.d6008", "Stickers.SnowLeopard.CheckpointNoSticker08A", 
    "ActiveStickers.d6009", "Stickers.SnowLeopard.CheckpointNoSticker09A", "ActiveStickers.d6010", "ActiveStickers.d6011", 
    "ActiveStickers.d6012", "Stickers.Eagle.CheckpointNoSticker12A", "Stickers.Eagle.CheckpointNoSticker12A", 
    "Stickers.Eagle.CheckpointNoSticker12B", "ActiveStickers.d6013", "Stickers.Eagle.CheckpointNoSticker13A", 
    "Stickers.Eagle.CheckpointNoSticker14A", "ActiveStickers.d6014", "ActiveStickers.d6015",
}
local stickerNotifiedNoObjects = false
local stickerNotifiedError = false

-- Plataforma anti-ca√≠da
local platform = nil
local platformFollowConn = nil
local PLATFORM_SIZE = Vector3.new(6, 1, 6)
local PLATFORM_TRANSPARENCY = 0.35
local PLATFORM_COLOR = Color3.fromRGB(30, 144, 255)
local platformYOffset = 0.1

-- =========================
-- L√ìGICA DE PLATAFORMA (Mantenida)
-- =========================

local platformManualEnabled = false -- * Controlado por el Toggle
local platformForceDisabled = false -- * Controlado por el Toggle

local function destroyPlatform()
    -- ... Tu funci√≥n original ...
    if platformFollowConn then
        pcall(function() platformFollowConn:Disconnect() end)
        platformFollowConn = nil
    end
    if platform and platform.Parent then
        pcall(function() platform:Destroy() end)
    end
    platform = nil
    if hud and hud.Notify then hud:Notify("Plataforma desactivada") end
end

local function createPlatform()
    -- ... Tu funci√≥n original ...
    if platformForceDisabled then return end
    if platform and platform.Parent then return end
    local character = LocalPlayer and LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local p = Instance.new("Part")
    p.Name = "TeleportPlatform_" .. tostring(LocalPlayer and LocalPlayer.UserId or "Local")
    p.Size = PLATFORM_SIZE
    p.Anchored = true
    p.CanCollide = true
    p.Transparency = PLATFORM_TRANSPARENCY
    p.Material = Enum.Material.SmoothPlastic
    p.Color = PLATFORM_COLOR
    p.TopSurface = Enum.SurfaceType.Smooth
    p.BottomSurface = Enum.SurfaceType.Smooth
    p.Parent = Workspace

    local hrpSizeY = (hrp.Size and hrp.Size.Y) or 2
    local yOffset = (hrpSizeY / 2) + (p.Size.Y / 2) + 0.1
    platformYOffset = yOffset
    p.CFrame = CFrame.new(hrp.Position - Vector3.new(0, yOffset, 0))

    platform = p

    platformFollowConn = RunService.Heartbeat:Connect(function()
        if not LocalPlayer or not LocalPlayer.Character then
            destroyPlatform()
            return
        end
        local curHrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not curHrp then
            destroyPlatform()
            return
        end
        local currentY = platform and platform.Parent and platform.Position.Y or (curHrp.Position.Y - platformYOffset)
        local targetPos = Vector3.new(curHrp.Position.X, currentY, curHrp.Position.Z)
        platform.CFrame = CFrame.new(targetPos)
    end)

    if hud and hud.Notify then hud:Notify("Plataforma activada") end
end

local function ensurePlatformUnderCharacterInstant()
    -- ... Tu funci√≥n original ...
    if not platform or not platform.Parent then return end
    local character = LocalPlayer and LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local yOffset = platformYOffset or (((hrp.Size and hrp.Size.Y) or 2) / 2 + (platform.Size.Y / 2) + 0.1)
    platform.CFrame = CFrame.new(hrp.Position - Vector3.new(0, yOffset, 0))
end

local function updatePlatformState()
    -- ... Tu funci√≥n original, adaptada a las nuevas variables de control de estado ...
    if platformForceDisabled then
        if platform and platform.Parent then pcall(destroyPlatform) end
        return
    end

    if teleporting or multiTeleporting or stickerTeleporting or platformManualEnabled then
        if not platform or not platform.Parent then pcall(createPlatform) end
    else
        if platform and platform.Parent then pcall(destroyPlatform) end
    end
end

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function(char)
        wait(0.1)
        if platform and platform.Parent then
            pcall(destroyPlatform)
            wait(0.05)
            pcall(function()
                if not platformForceDisabled then createPlatform() end
            end)
        end
    end)
end

-- =========================
-- Funciones de teletransporte (Mantenidas)
-- =========================

local function teleportToInstance(instance)
    -- ... Tu funci√≥n original ...
    if not instance then return false end

    local targetCFrame = nil
    if instance:IsA("BasePart") then
        targetCFrame = instance.CFrame
    elseif instance:IsA("Model") and instance.PrimaryPart then
        targetCFrame = instance.PrimaryPart.CFrame
    end

    if targetCFrame then
        local success, err = pcall(function()
            local player = LocalPlayer
            if player and player.Character and player.Character.PrimaryPart then
                player.Character:SetPrimaryPartCFrame(targetCFrame)
                pcall(ensurePlatformUnderCharacterInstant) -- Mover plataforma inmediatamente
            end
        end)
        return success
    end
    return false
end

local function teleportToObject(objectName)
    local pickupsFolder = Workspace:FindFirstChild("Pickups")
    if not pickupsFolder then return false end
    local object = pickupsFolder:FindFirstChild(objectName)
    if not object then return false end

    if object:IsA("Model") and object.PrimaryPart then
        return teleportToInstance(object.PrimaryPart)
    else
        return teleportToInstance(object)
    end
end

-- =========================
-- L√ìGICA DE BUCLES (Mantenida y adaptada al callback de Toggle)
-- =========================

-- Bucle BUSCAR
local function startTeleportLoop()
    spawn(function()
        while teleporting do
            local found = teleportToObject(teleportObjectName)
            if found then
                if hud and hud.Notify then hud:Notify("Objeto encontrado (auto-win desactivado). Usa el bot√≥n GANAR.") end
                if notifiedNoObjects then notifiedNoObjects = false end
            else
                if not notifiedNoObjects and hud and hud.Notify then
                    hud:Notify("No hay objetos")
                    notifiedNoObjects = true
                end
            end
            wait(TELEPORT_INTERVAL)
        end
        updatePlatformState()
    end)
end

local function toggleTeleporting(objectName, state)
    teleportObjectName = objectName
    teleporting = state
    
    if state then
        startTeleportLoop()
        if hud and hud.Notify then hud:Notify("B√∫squeda activada (busca: " .. objectName .. ")") end
    else
        if hud and hud.Notify then hud:Notify("B√∫squeda desactivada") end
        notifiedNoObjects = false
    end
    updatePlatformState()
end

-- Bucle PICKUPS
local function gatherMultiTargets()
    local targets = {}
    local slotsRoot = Workspace:FindFirstChild("PickupSlots")
    if not slotsRoot then return targets end

    for _, slotName in ipairs(multiPickupSlotNames) do
        local slot = slotsRoot:FindFirstChild(slotName)
        if slot then
            local def = slot:FindFirstChild("Default")
            if def then table.insert(targets, def) end
        end
    end
    return targets
end

local function startMultiTeleportOnce()
    spawn(function()
        local targets = gatherMultiTargets()

        if #targets == 0 then
            -- ... (L√≥gica de notificaci√≥n si no hay targets) ...
            if not multiNotifiedNoObjects and hud and hud.Notify then hud:Notify("No hay pickups disponibles") end
            multiTeleporting = false
        else
            if multiNotifiedNoObjects then multiNotifiedNoObjects = false end
        end

        for i = 1, #targets do
            local target = targets[i]
            local ok = false
            local success, err = pcall(function() ok = teleportToInstance(target) end)

            if not success or not ok then
                if not multiNotifiedError and hud and hud.Notify then hud:Notify("Error o pickup no v√°lido en √≠ndice " .. tostring(i)) end
                multiNotifiedError = true
            else
                if hud and hud.Notify then hud:Notify("Teletransportado a pickup (" .. tostring(i) .. ")") end
                if multiNotifiedError then multiNotifiedError = false end
            end
            wait(MULTI_TELEPORT_INTERVAL)
        end

        multiTeleporting = false
        if hud and hud.Notify then hud:Notify("Ciclo de pickups finalizado") end
        -- Necesitamos resetear visualmente el toggle:
        -- Esto requiere que guardemos una referencia al control del toggle, lo haremos en la UI.
        
        -- Si el toggle de la UI existe, lo apagamos:
        if hud._controls and hud._controls.PICKUP_TOGGLE then
            hud._controls.PICKUP_TOGGLE:SetValue(false)
        end
        updatePlatformState()
    end)
end

local function toggleMultiTeleport(state)
    multiTeleporting = state
    if state then
        if hud and hud.Notify then hud:Notify("Iniciando pasada de pickups") end
        startMultiTeleportOnce()
    else
        -- La detenci√≥n solo ocurre autom√°ticamente al final de la pasada, 
        -- pero si el usuario presiona, simplemente lo ignoramos hasta que la pasada termine.
        -- Como la pasada es "Once", no necesitamos l√≥gica de `CancelRequested`.
    end
    updatePlatformState()
end

-- Bucle STICKERS
local function findNodeByPath(path)
    -- ... Tu funci√≥n original ...
    local node = Workspace
    for seg in string.gmatch(path, "[^%.]+") do
        if node then node = node:FindFirstChild(seg) else break end
    end
    return node
end

local function gatherStickerTargets()
    local targets = {}
    for _, relPath in ipairs(stickerPaths) do
        local node = findNodeByPath(relPath)
        if node then
            local touch = node:FindFirstChild("Touch")
            if touch then table.insert(targets, touch) end
        end
    end
    return targets
end

local function startStickerTeleportOnce()
    spawn(function()
        local targets = gatherStickerTargets()

        if #targets == 0 then
            if not stickerNotifiedNoObjects and hud and hud.Notify then hud:Notify("No hay stickers disponibles") end
            stickerTeleporting = false
        else
            if stickerNotifiedNoObjects then stickerNotifiedNoObjects = false end
        end

        for i = 1, #targets do
            local target = targets[i]
            local ok = false
            local success, err = pcall(function() ok = teleportToInstance(target) end)
            
            if not success or not ok then
                if not stickerNotifiedError and hud and hud.Notify then hud:Notify("Error o sticker no v√°lido en √≠ndice " .. tostring(i)) end
                stickerNotifiedError = true
            else
                if hud and hud.Notify then hud:Notify("Teletransportado a sticker (" .. tostring(i) .. ")") end
                if stickerNotifiedError then stickerNotifiedError = false end
            end
            wait(STICKER_TELEPORT_INTERVAL)
        end

        stickerTeleporting = false
        if hud and hud.Notify then hud:Notify("Ciclo de stickers finalizado") end
        -- Apagar visualmente el toggle:
        if hud._controls and hud._controls.STICKER_TOGGLE then
            hud._controls.STICKER_TOGGLE:SetValue(false)
        end
        updatePlatformState()
    end)
end

local function toggleStickerTeleport(state)
    stickerTeleporting = state
    if state then
        if hud and hud.Notify then hud:Notify("Iniciando pasada de stickers") end
        startStickerTeleportOnce()
    end
    updatePlatformState()
end


-- Funci√É¬≥n GANAR
local function doWinTeleport()
    local player = LocalPlayer
    local success, destination = pcall(function()
        return Workspace.Utility.Teleporters.Portal_to_Wc.Portal["Canvas Clouds"]:FindFirstChild("Cylinder")
    end)

    if success and destination then
        pcall(function()
            if player and player.Character and player.Character.PrimaryPart then
                player.Character:SetPrimaryPartCFrame(destination.CFrame)
                pcall(ensurePlatformUnderCharacterInstant)
                if hud and hud.Notify then hud:Notify("Teletransportado a GANAR") end
            end
        end)
    else
        if hud and hud.Notify then hud:Notify("Destino GANAR no encontrado") end
    end
end


-- =========================
-- CREACI√ìN DE LA UI FINAL
-- =========================

-- Creamos una tabla temporal para guardar las referencias de los Toggles
hud._controls = {} 

-- 1. SECCI√ìN DE COMBATE/WIN
local winSection = hud:AddSection("üèÜ Win / Teleport")

winSection:AddButton("GANAR üèÅ", function()
    doWinTeleport()
end)

-- 2. SECCI√ìN DE B√öSQUEDA Y CICLOS
local cycleSection = hud:AddSection("üî≠ Teleport Cycles")

-- BUSCAR (Toggle, asumiendo que busca "Default" por defecto)
local searchToggle = cycleSection:AddToggle("BUSCAR (Default) üîç", false, function(state)
    toggleTeleporting("Default", state)
end)

-- CICLO PICKUPS (Toggle)
local pickupToggle = cycleSection:AddToggle("CICLO PICKUPS ‚ôªÔ∏è", false, function(state)
    -- Guardamos la referencia para apagarlo visualmente al final del ciclo
    hud._controls.PICKUP_TOGGLE = pickupToggle 
    toggleMultiTeleport(state)
end)

-- CICLO STICKERS (Toggle)
local stickerToggle = cycleSection:AddToggle("CICLO STICKERS ‚≠ê", false, function(state)
    -- Guardamos la referencia para apagarlo visualmente al final del ciclo
    hud._controls.STICKER_TOGGLE = stickerToggle 
    toggleStickerTeleport(state)
end)

-- 3. SECCI√ìN DE HERRAMIENTAS
local toolsSection = hud:AddSection("üõ†Ô∏è Tools / Fixes")

-- PLATAFORMA (Toggle)
toolsSection:AddToggle("PLATAFORMA üõ°Ô∏è", false, function(state)
    -- Usamos el estado del Toggle para controlar las variables de la plataforma
    platformManualEnabled = state
    platformForceDisabled = not state -- Si est√° ON, quitamos la fuerza de desactivado
    
    if state then
        pcall(createPlatform)
        if hud and hud.Notify then hud:Notify("Plataforma manual: ON") end
    else
        pcall(destroyPlatform)
        if hud and hud.Notify then hud:Notify("Plataforma manual: OFF (forzada)") end
    end
    updatePlatformState()
end)
